#!/bin/sh

### BEGIN INIT INFO
# Provides:          imagen-publication
# Required-Start:    $remote_fs $syslog $local_fs $network
# Required-Stop:     $remote_fs $syslog $local_fs $network
# Should-Start:      postgresql
# Should-Stop:       postgresql
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Imagen V2
# Description:       Publish Imagen data using the Cubicweb semantic web framework.
### END INIT INFO

#set -e

PATH=/sbin:/usr/sbin:/bin:/usr/bin

VIRTUALENV_HOME="/home/imagen/virtualenvs/imagen_publication"
DAEMON="$VIRTUALENV_HOME/bin/cubicweb-ctl"
DAEMON_OPT="imagen_publication"
DAEMON_NAME=`basename "$DAEMON"`
DAEMON_USER=imagen
VIRTUALENV_CONF="$VIRTUALENV_HOME/bin/activate"
CW_PID="$VIRTUALENV_HOME/var/run/cubicweb/$DAEMON_OPT-all-in-one.pid"


# Exit if the package is not installed
test -x "$DAEMON" || exit 0

# Load the VERBOSE setting and other rcS variables
. /lib/init/vars.sh

# Define LSB log_* functions.
. /lib/lsb/init-functions


#
# Function that starts the daemon/service
#
d_start () {
    # Return
    #   0 if daemon has been started
    #   1 if daemon was already running
    #   2 if daemon could not be started
    log_daemon_msg "Starting system '$DAEMON_NAME' daemon for user '$DAEMON_USER'"
    d_status_inner
    case "$?" in
        0)
            d_status_inner 1
            return 1
            ;;
    esac
    su - $DAEMON_USER -s /bin/bash -c ". $VIRTUALENV_CONF && $DAEMON start $DAEMON_OPT" || return 2
    return 0
}


#
# Function that stops the daemon/service
#
d_stop () {
    # Return
    #   0 if daemon has been stopped
    #   1 if daemon was already stopped
    #   2 if daemon could not be stopped
    log_daemon_msg "Stopping system '$DAEMON_NAME' daemon for user '$DAEMON_USER'"
    d_status_inner
    case "$?" in
        1)
            d_status_inner 1
            return 1
            ;;
    esac
    su - $DAEMON_USER -s /bin/bash -c ". $VIRTUALENV_CONF && $DAEMON stop $DAEMON_OPT" || return 2
    return 0
}


#
# Function that gives the status of the daemon/service
#
d_status() {
    # Return
    #   0 if daemon is started
    #   1 if daemon is stopped
    log_daemon_msg "'$DAEMON_NAME' daemon for user '$DAEMON_USER' status"
    d_status_inner 1
    log_end_msg $?
}
d_status_inner() {
    # If an input is specified, display the cw status message
    # Return
    #   0 if daemon is started
    #   1 if daemon is stopped
    returncode=$(su - $DAEMON_USER -s /bin/bash -c ". $VIRTUALENV_CONF && $DAEMON status $DAEMON_OPT")
    if ! [ $# -eq 0 ]
        then
            echo $returncode
    fi
    case "$returncode" in
        *pid*) return 0 ;;
    esac
    return 1
}
d_pid() {
    # Return
    #   pid the CubicWeb process id
    #   0 if daemon is stopped
    returncode=$(su - $DAEMON_USER -s /bin/bash -c ". $VIRTUALENV_CONF && $DAEMON status $DAEMON_OPT")
    IFS=" "
    set -- $returncode
    pid="$5"
    case $pid in
        ""|*[!0-9]*) return 0 ;;
        *) return $pid ;;
    esac
}


#
# Implement daemon/service options
#
case "$1" in
    restart|reload)
        d_stop
        case "$?" in
            1|2)
                log_end_msg 1
                exit 1;;
        esac
        d_start
        case "$?" in
            0) log_end_msg 0 ;;
            1|2) log_end_msg 1 ;;
        esac
        ;;
    force-reload)
        d_stop
        d_start
        case "$?" in
            0) log_end_msg 0 ;;
            1|2) log_end_msg 1 ;;
        esac
        ;;
    force-stop)
        d_pid
        pid="$?"
        d_stop
        case "$?" in
            0|1)
                log_end_msg 0
                exit 0
                ;;
            2) echo "Trying to kill the process" ;;
        esac
        if [ -f "$CW_PID" ]
            then
                killproc $pid;
                case "$?" in
                    0) "'$pid' killed" ;;
                    *)
                        log_end_msg 1
                        exit 1
                        ;;
                esac
                rm $CW_PID;
        else
            log_end_msg 1;
        fi
        ;;
    status)
        d_status
        ;;
    start|stop)
        d_${1}
        case "$?" in
            0) log_end_msg 0 ;;
            1|2) log_end_msg 1 ;;
        esac
        ;;
esac
exit 0
